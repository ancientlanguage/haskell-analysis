module XmlEvents where

import Conduit
import Control.Exception (Exception (..), SomeException)
import Control.Monad.Trans.Resource
import qualified Data.Char as Char
import Data.Conduit.Attoparsec (PositionRange)
import qualified Data.Conduit.Internal as CI
import qualified Data.Text as Text
import Data.XML.Types
import Text.XML.Stream.Parse hiding (AttrParser)

readEvents :: FilePath -> IO [EventPos]
readEvents path = runResourceT $ sourceFile path =$= parseBytesPos def $$ sinkList

tag :: MonadThrow m
    => (Name -> Maybe a) -- ^ Check if this is a correct tag name
                         --   and return a value that can be used to get an @AttrParser@.
                         --   If this returns @Nothing@, the function will also return @Nothing@
    -> (a -> AttrParser b) -- ^ Given the value returned by the name checker, this function will
                           --   be used to get an @AttrParser@ appropriate for the specific tag.
    -> (b -> CI.ConduitM Event o m c) -- ^ Handler function to handle the attributes and children
                                      --   of a tag, given the value return from the @AttrParser@
    -> CI.ConduitM Event o m (Maybe c)
tag checkName attrParser f = do
    (x, leftovers) <- dropWS []
    res <- case x of
        Just (EventBeginElement name as) ->
            case checkName name of
                Just y ->
                    case runAttrParser' (attrParser y) as of
                        Left e -> lift $ monadThrow e
                        Right z -> do
                            z' <- f z
                            (a, _leftovers') <- dropWS []
                            case a of
                                Just (EventEndElement name')
                                    | name == name' -> return (Just z')
                                _ -> lift $ monadThrow $ XmlException ("Expected end tag for: " ++ show name) a
                Nothing -> return Nothing
        _ -> return Nothing

    case res of
        -- Did not parse, put back all of the leading whitespace events and the
        -- final observed event generated by dropWS
        Nothing -> mapM_ leftover leftovers
        -- Parse succeeded, discard all of those whitespace events and the
        -- first parsed event
        Just _ -> return ()

    return res
  where
    -- Drop Events until we encounter a non-whitespace element. Return all of
    -- the events consumed here (including the first non-whitespace event) so
    -- that the calling function can treat them as leftovers if the parse fails
    dropWS leftovers = do
        x <- await
        let isWS =
                case x of
                    Just EventBeginDocument -> True
                    Just EventEndDocument -> True
                    Just EventBeginDoctype{} -> True
                    Just EventEndDoctype -> True
                    Just EventInstruction{} -> True
                    Just EventBeginElement{} -> False
                    Just EventEndElement{} -> False
                    Just (EventContent (ContentText t))
                        | Text.all Char.isSpace t -> True
                        | otherwise -> False
                    Just (EventContent ContentEntity{}) -> False
                    Just EventComment{} -> True
                    Just EventCDATA{} -> False
                    Nothing -> False
            leftovers' = maybe id (:) x leftovers
        if isWS
            then dropWS leftovers'
            else return (x, leftovers')
    runAttrParser' p as =
        case runAttrParser p as of
            Left e -> Left e
            Right ([], x) -> Right x
            Right (attr, _) -> Left $ toException $ UnparsedAttributes attr

newtype AttrParser a = AttrParser { runAttrParser :: [(Name, [Content])] -> Either SomeException ([(Name, [Content])], a) }
